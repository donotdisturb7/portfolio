---
title: "Optimiser des applications"
subtitle: "Algorithmes de pathfinding dans un labyrinthe Python"
publishedAt: "2024-01-16"
summary: "Développer, comparer et optimiser trois algorithmes de recherche de chemin : Dijkstra, A* et BFS"
image: "/images/projects/project-02/calc.png"
---

# Optimiser des applications

## Niveau 1 - Appréhender et construire des algorithmes

### Analyser un problème avec méthode de découpage en éléments algorithmiques simples

**Description :** Décomposer un problème complexe en sous-problèmes algorithmiques simples et identifier les structures de données appropriées.

**Ce que j'ai fait dans les Algorithmes de Labyrinthe :**
- Analysé le problème de pathfinding en sous-problèmes : représentation du labyrinthe, exploration des nœuds, calcul des distances
- Identifié les structures nécessaires : matrices 2D pour le labyrinthe, listes pour les chemins, files de priorité pour l'exploration
- Décomposé l'algorithme en étapes : initialisation, exploration des voisins, calcul de coût, reconstruction du chemin
- Modélisé les données avec des structures optimisées (graphes, coordonnées x/y, états visités)
- Créé des algorithmes de parsing pour lire les fichiers de labyrinthe

**Technologies utilisées :** Python, structures de données (listes, dictionnaires, sets), matrices NumPy, algorithmes de graphes

### Comparer des algorithmes pour des problèmes classiques

**Description :** Évaluer et comparer différents algorithmes de tri, recherche et optimisation selon leurs performances.

**Ce que j'ai fait dans les Algorithmes de Labyrinthe :**
- Comparé trois algorithmes : Dijkstra (optimal mais lent), A* (optimal et rapide), BFS (non-optimal mais simple)
- Mesuré les performances : temps d'exécution, nombre de nœuds explorés, longueur du chemin trouvé
- Testé sur différentes tailles de labyrinthes (10x10, 50x50, 100x100) pour analyser la scalabilité
- Analysé la complexité temporelle et spatiale : O(V log V) pour Dijkstra, O(b^d) pour BFS
- Créé des graphiques comparatifs des performances avec matplotlib

**Technologies utilisées :** Python avec module time, matplotlib pour les graphiques, benchmarking

### Formaliser et mettre en œuvre des outils mathématiques pour l'informatique

**Description :** Appliquer des concepts mathématiques (statistiques, algèbre linéaire, probabilités) dans le développement informatique.

**Ce que j'ai fait dans les Algorithmes de Labyrinthe :**
- Utilisé la distance euclidienne et Manhattan pour les heuristiques d'A*
- Appliqué des calculs de plus court chemin avec l'algorithme de Dijkstra
- Implémenté des fonctions de coût et d'heuristique mathématiques
- Utilisé des concepts de théorie des graphes (voisinage, connectivité)
- Calculé des statistiques sur les performances (moyenne, médiane, écart-type)

**Technologies utilisées :** 



### Choisir des structures de données complexes adaptées au problème

**Description :** Sélectionner et implémenter des structures de données avancées pour optimiser les performances.

**Ce que j'ai fait dans le ChatBot AI avec Ollama :**
- Implémenté un système de gestion des contextes LLM avec historique conversationnel optimisé
- Créé des structures de données pour gérer les prompts avec template et injection de variables
- Utilisé des queues thread-safe pour gérer les flux audio en temps réel sans blocage
- Optimisé le stockage des embeddings et tokens pour réduire la latence du LLM
- Implémenté un cache intelligent pour les réponses fréquentes du chatbot
- Géré des buffers circulaires pour l'audio streaming continu

**Technologies utilisées :** 

### Utiliser des technologies algorithmiques adaptées pour des problèmes complexes

**Description :** Implémenter des algorithmes avancés comme l'IA, la recherche opérationnelle et l'optimisation globale.

**Comment faire qu'un LLM généraliste réponde précisément sur l'IUT de la Martinique sans halluciner d'informations ?**

**L'algorithme adapté :** Le RAG combine deux technologies :
- Recherche sémantique (pour trouver l'info pertinente)
- Génération de texte (pour formuler la réponse)

**Ce que j'ai fait dans le ChatBot AI avec Ollama :**
- Intégré des modèles de langage (LLM) locaux avec Ollama pour le traitement du langage naturel
- Implémenté des algorithmes de Speech-to-Text pour la reconnaissance vocale en temps réel
- Utilisé des réseaux de neurones pour la synthèse vocale avec l'API ElevenLabs
- Optimisé les algorithmes de prompt engineering pour améliorer les réponses du LLM
- Appliqué des techniques de machine learning pour la détection d'intention et le context switching
- Développé des algorithmes de streaming audio avec réduction de bruit et normalisation

**Technologies utilisées :** LLM (Large Language Models), Speech-to-Text AI, Neural TTS, prompt engineering, ML intent detection, audio processing algorithms

### Évaluer l'impact environnemental et sociétal des solutions proposées

**Description :** Analyser les conséquences écologiques et sociales des algorithmes développés.

**Ce que j'ai fait dans les Algorithmes de Labyrinthe :**
- Mesuré la consommation CPU et mémoire de chaque algorithme avec des outils de profiling
- Analysé l'impact énergétique : A* consomme moins d'énergie car plus rapide que Dijkstra
- Documenté le trade-off entre précision et efficacité énergétique
- Étudié l'applicabilité dans des contextes réels (GPS, robotique) et leur impact environnemental
- Optimisé les algorithmes pour réduire l'empreinte carbone des calculs intensifs

**Technologies utilisées :**  